<!DOCTYPE html>
<html lang="ja" class="booting">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Font2SVG - Text to SVG Converter</title>
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
  <style>
    :root {
      --bg: #0b0c10;
      --primary: #ac00ac;
      --accent: #f93ca4;
      --fg: #1b1648;
      --muted: #a7adbb;
      --card: #ffffff;
      --card-soft: #f3eeff;
      --ring: #dcd6ff;
      --ring-strong: #b6aef5;
      --accent-strong: #AE75DA;
      --shadow: 0 18px 40px rgba(72, 45, 154, .12);
      --panel: #151821;
      --ink: #e8eaf0;
      --chip: #222735;
      --wrap-margin-bottom: 64px;
      --wrap-padding-bottom: 48px;
      --card-padding-bottom: 24px;
      /* Physicalオフセット: 角丸領域とスクロールバー/内容物を離す */
      --preview-scroll-offset: 12px;
      /* 調整用。overlay scrollbar 環境では 0 に */
    }

    :root.preview-compact {
      --wrap-margin-bottom: 28px;
      --wrap-padding-bottom: 20px;
      --card-padding-bottom: 16px;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-size: 1.2em;
      line-height: 1.7;
      font-family: "Inter", "Hiragino Kaku Gothic ProN", "Noto Sans JP", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    /* 初期レイアウト安定まで一時的に不可視化（CLS低減）。JS失敗時フォールバックで5s後フェードイン */
    html.booting body {
      opacity: 0;
    }

    body {
      transition: opacity .25s ease;
    }

    @keyframes booting-fallback-show {
      to {
        opacity: 1;
      }
    }

    html.booting body.booting-fallback {
      animation: booting-fallback-show 0s linear 5s forwards;
    }

    .preview-scroll {
      position: absolute;
      inset: 0;
      right: var(--preview-scroll-offset);
      padding: 14px 12px 14px 12px;
      /* 上下余白増しで角丸欠け軽減 */
      box-sizing: border-box;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-gutter: stable;
    }

    .wrap {
      max-width: 1200px;
      margin: 8px auto var(--wrap-margin-bottom);
      padding: 0 24px 48px var(--wrap-padding-bottom);
      display: grid;
      gap: 28px;
    }

    header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: linear-gradient(180deg, rgba(0, 0, 0, .6), rgba(0, 0, 0, 0));
      backdrop-filter: blur(6px);
      margin-top: 16px;
    }

    header .wrap {
      display: flex;
      align-items: flex-start;
      gap: 24px;
      padding: 0px;
      margin: 0 auto;
    }

    h1 {
      font-size: 32px;
      font-weight: 700;
      margin: 0;
      letter-spacing: .01em;
    }

    h2 {
      font-size: 20px;
      font-weight: 600;
      margin: 0 0 14px;
      letter-spacing: .02em;
    }

    header p {
      margin: 0;
      color: var(--muted);
      font-size: 15px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--chip);
      border-radius: 20px;
      padding: 22px 24px var(--card-padding-bottom);
      box-shadow: var(--shadow);
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
    }

    .card .row:nth-child(2) {
      align-items: flex-start;
      margin-top: 12px;
    }

    .card .row:nth-child(3) {
      margin-top: 12px;
    }

    .switcher {
      position: relative;
      flex: 0 1 360px;
      min-width: 280px;
      min-height: 52px;
      width: clamp(280px, 36vw, 400px);
      max-width: 100%;
    }

    /* フォントファミリ select/ボタンとスタイル select の縦位置を揃える */
    .fontControls,
    .switcher,
    .switcher .switchItem,
    .styleSelect {
      min-height: 52px;
    }

    .switcher .switchItem,
    .styleSelect:not(.is-hidden) {
      display: flex;
      align-items: center;
    }

    /* ネイティブ select の行高ばらつきを吸収（表示時のみ適用） */
    .switcher select,
    .styleSelect:not(.is-hidden) {
      height: 52px;
      line-height: 52px;
      padding-top: 0;
      padding-bottom: 0;
    }

    /* フォント読み込みボタンの高さを select と揃える */
    #btnListLocal.btn {
      height: 52px;
      display: inline-flex;
      align-items: center;
    }

    .switcher .switchItem {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      display: flex;
      align-items: center;
      gap: 16px;
      opacity: 0;
      pointer-events: none;
      transform: translateY(8px);
      transition: opacity .24s ease, transform .24s ease;
    }

    #fontButtonWrap {
      width: fit-content;
    }

    .switcher .switchItem.is-active {
      opacity: 1;
      pointer-events: auto;
      transform: translateY(0);
    }

    .switcher select,
    .switcher button {
      width: 100%;
      min-width: 0;
    }

    .fontControls {
      flex: 1 1 auto;
      min-width: 320px;
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }

    .styleSelect {
      flex: 0 1 220px;
      min-width: 180px;
    }

    .styleSelect.is-hidden {
      display: none;
    }

    .btn {
      appearance: none;
      border: 0;
      border-radius: 12px;
      padding: 8px 16px;
      background: var(--primary);
      color: #fff;
      font-weight: 600;
      letter-spacing: .02em;
      cursor: pointer;
      transition: transform .18s ease, opacity .2s ease;
      outline: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      width: fit-content;
    }

    .btn .material-symbols-outlined {
      color: white;
    }

    .char-dl-btn {
      padding: 6px 12px;
    }

    .char-dl-btn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .char-dl-btn[disabled] {
      opacity: .45;
      cursor: not-allowed;
    }

    .btn:hover:not([disabled]) {
      outline: 2px solid var(--accent-strong);
      outline-offset: 2px;
    }

    .btn:active:not([disabled]) {
      background: var(--accent);
    }

    .btn:focus {
      outline: none;
    }

    .btn:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .btn[disabled] {
      opacity: .45;
      cursor: not-allowed;
      box-shadow: none
    }

    label.inline {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-weight: 400;
      color: var(--ink)
    }

    .material-symbols-outlined {
      font-family: "Material Symbols Outlined";
      font-weight: normal;
      font-style: normal;
      font-size: 20px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      letter-spacing: normal;
      text-transform: none;
      white-space: nowrap;
      direction: ltr;
      font-feature-settings: "liga";
      -webkit-font-feature-settings: "liga";
      -webkit-font-smoothing: antialiased;
      font-variation-settings:
        "FILL" 0,
        "wght" 400,
        "GRAD" 0,
        "opsz" 24;
      color: var(--accent-strong);
    }

    select,
    textarea,
    input[type="number"],
    input[type="range"],
    input[type="checkbox"],
    input[type="color"] {
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid var(--chip);
      background: var(--chip);
      color: var(--ink);
      font: inherit;
      transition: border-color .15s ease, box-shadow .15s ease;
      accent-color: var(--accent);
    }

    select:focus,
    textarea:focus,
    input[type="number"]:focus,
    input[type="range"]:focus,
    input[type="checkbox"]:focus,
    input[type="color"]:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(172, 0, 172, .22)
    }

    textarea {
      min-width: 472px;
      width: 592px;
      min-height: 96px;
      resize: vertical;
    }

    input[type="range"] {
      padding: 0;
      background: transparent
    }

    input[type="color"] {
      padding: 0;
      width: 52px;
      height: 38px;
      border-radius: 8px;
      background: var(--chip)
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      padding: 0;
      border-radius: 4px;
      background: var(--chip);
      border: 1px solid var(--chip)
    }

    .number-input-wrapper {
      position: relative;
      display: inline-block;
      width: 80px;
    }

    .number-input-wrapper input {
      width: 100%;
      appearance: textfield;
      -moz-appearance: textfield;
      padding-right: 20px;
    }

    .number-input-wrapper input::-webkit-outer-spin-button,
    .number-input-wrapper input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    .spin-buttons {
      position: absolute;
      right: 2px;
      top: 2px;
      bottom: 2px;
      display: flex;
      flex-direction: column;
      width: 16px;
      gap: 1px;
    }

    .spin-up,
    .spin-down {
      flex: 1;
      background: var(--primary);
      border: 1px solid var(--panel);
      color: white;
      font-size: 8px;
      line-height: 1;
      padding: 0;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
    }

    .spin-up:hover,
    .spin-down:hover {
      background: var(--accent-strong);
    }

    a {
      color: var(--accent-strong);
      text-decoration: none;
      font-weight: 400
    }

    a:hover {
      text-decoration: underline
    }

    .help {
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6
    }

    .preview {
      /* outer wrapper: handles border radius & clipping, inner handles scrolling */
      min-height: 240px;
      border: 1px solid var(--chip);
      border-radius: 20px;
      background: linear-gradient(180deg, rgba(34, 39, 53, .9) 0%, rgba(21, 24, 33, .92) 100%);
      overflow: hidden;
      /* 角丸外を確実にカット */
      position: relative;
      contain: paint;
    }

    /* （二重定義防止）preview-scroll の余白は上部で統合済み */

    /* Restored custom scrollbar (lost in refactor 07a7120) */
    .preview-scroll,
    .tile .box {
      scrollbar-width: thin;
      /* Firefox */
      scrollbar-color: var(--primary) var(--chip);
      /* thumb track */
    }

    .preview-scroll::-webkit-scrollbar,
    .tile .box::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }

    /* duplicate .preview block removed (consolidated above) */

    .tile .foot {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 6px;
      border: 0;
      border-radius: 0;
    }

    .preview-scroll::-webkit-scrollbar-track,
    .tile .box::-webkit-scrollbar-track {
      background: var(--chip);
      border-radius: 999px;
    }

    .preview-scroll::-webkit-scrollbar-thumb,
    .tile .box::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 999px;
      border: 2px solid var(--panel);
      background-clip: padding-box;
    }

    .preview-scroll::-webkit-scrollbar-thumb:hover,
    .tile .box::-webkit-scrollbar-thumb:hover {
      background: var(--accent-strong);
    }

    /* overlay scrollbar 環境向け（macOS など）: オフセットは意味がないので 0 に */
    .overlay-scrollbars .preview-scroll {
      right: 0;
    }

    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      background: var(--primary);
      border-radius: 3px;
      border: 1px solid var(--panel);
    }

    input[type="number"]::-webkit-outer-spin-button:hover,
    input[type="number"]::-webkit-inner-spin-button:hover {
      background: var(--accent-strong);
    }

    .preview.is-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: var(--muted);
      font-size: 15px;
    }

    .preview-loading {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 18px
    }

    .tile {
      background: var(--panel);
      border: 1px solid var(--chip);
      border-radius: 18px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      box-shadow: 0 14px 24px rgba(12, 16, 28, .6);
    }

    .tile .box {
      --checker-base: #10151f;
      --checker-overlay: rgba(255, 255, 255, .12);
      background-image: linear-gradient(45deg, var(--checker-overlay) 25%, transparent 25%, transparent 75%, var(--checker-overlay) 75%, var(--checker-overlay)),
        linear-gradient(45deg, var(--checker-overlay) 25%, transparent 25%, transparent 75%, var(--checker-overlay) 75%, var(--checker-overlay));
      background-size: 20px 20px;
      background-position: 0 0, 10px 10px;
      background-color: var(--checker-base);
      border: 1px solid var(--chip);
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 170px;
      overflow: auto;
      padding: 8px 21px 8px 8px;
    }

    .tile .meta {
      font-size: 1em;
      color: var(--muted);
      display: flex;
      /* foot 内では左寄せし、右ボタンとの間を自動スペース化 */
      justify-content: flex-start;
      align-items: center;
      gap: 4px;
      white-space: nowrap;
      padding: 0 0 0 2px;
      /* 左に2px余白追加 */
      margin-right: auto;
    }

    /* (削除済) 旧 .tile .foot 定義は下部に統合済 */

    footer {
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      text-align: center
    }

    @media (max-width:720px) {
      .wrap {
        margin: 32px auto var(--wrap-margin-bottom);
        padding: 0 18px var(--wrap-padding-bottom);
        gap: 22px
      }

      h1 {
        font-size: 26px
      }

      h2 {
        font-size: 19px
      }

      textarea {
        min-width: 100%;
        width: 100%
      }

      .switcher {
        flex-basis: 100%;
        min-width: 100%
      }

      .switcher select {
        min-width: 100%
      }

      .switcher {
        width: 100%;
      }

      .fontControls {
        flex-basis: 100%;
        min-width: 100%;
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .styleSelect {
        width: 100%;
        flex: 0 0 auto;
      }

      .row {
        gap: 12px
      }

      .card {
        padding: 20px 18px var(--card-padding-bottom)
      }
    }

    /* Loading overlay（一覧取得時のみ使用／フェード） */
    .loadingOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 18px;
      padding: 32px;
      background: rgba(5, 6, 10, 0.80);
      /* 単色半透明 */
      color: #fff;
      text-align: center;
      z-index: 1000;
      opacity: 0;
      pointer-events: none;
      transition: opacity .18s ease;
    }

    .loadingOverlay.show {
      opacity: 1;
      pointer-events: auto;
    }

    .loadingPanel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
      padding: 0;
      border: 0;
      background: transparent;
      box-shadow: none;
    }

    .loadingText {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 15px;
      line-height: 1.5;
    }

    #loadingMsg {
      font-size: 18px;
      font-weight: 600;
      letter-spacing: .02em;
    }

    #loadingPct {
      font-size: 14px;
      color: rgba(232, 234, 240, .8);
    }

    /* SVG ベース緩急付き円弧スピナー（シームレス版） */
    .spinner {
      --spinner-size: 64px;
      --spinner-stroke: 6px;
      width: var(--spinner-size);
      height: var(--spinner-size);
      display: inline-block;
    }

    .spinner svg {
      width: 100%;
      height: 100%;
      transform-origin: 50% 50%;
      animation: spinner-rotate 2.2s linear infinite;
    }

    /* 定長 + 強い緩急: dasharray 固定で dashoffset のみ非線形 */
    .spinner circle {
      fill: none;
      stroke: var(--primary);
      stroke-width: var(--spinner-stroke);
      stroke-linecap: round;
      stroke-dasharray: 35 65;
      stroke-dashoffset: 0;
      animation: spinner-dash 1.6s linear infinite;
    }

    @keyframes spinner-rotate {
      100% {
        transform: rotate(360deg);
      }
    }

    /* dasharray 固定: オフセットのみで「溜め→加速→減速」 */
    @keyframes spinner-dash {
      0% {
        stroke-dashoffset: 0;
      }

      6% {
        stroke-dashoffset: -2;
      }

      14% {
        stroke-dashoffset: -6;
      }

      24% {
        stroke-dashoffset: -14;
      }

      36% {
        stroke-dashoffset: -26;
      }

      50% {
        stroke-dashoffset: -50;
      }

      64% {
        stroke-dashoffset: -74;
      }

      76% {
        stroke-dashoffset: -86;
      }

      86% {
        stroke-dashoffset: -94;
      }

      94% {
        stroke-dashoffset: -98;
      }

      100% {
        stroke-dashoffset: -100;
      }
    }

    .title-block {
      flex: 1;
    }

    .header-actions {
      display: grid;
      grid-template-columns: max-content;
      justify-items: end;
      gap: 6px;
      margin-left: auto;
    }

    .header-actions>* {
      justify-self: end;
    }

    .lang-select {
      width: auto;
      margin: 0;
    }

    .x-link {
      text-decoration: none;
      padding: 6px 10px;
      border-radius: 8px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid var(--primary);
      background: transparent;
      color: #fff;
      font-size: 1.1rem;
    }

    .x-link:hover {
      opacity: .8;
      text-decoration: none
    }

    .x-link img {
      width: 24px;
      height: 24px;
      border-radius: 50%;
    }

    /* 旧 spin アニメーションは不要 */
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="wrap">
        <select id="lang" class="lang-select">
          <option value="ja">日本語</option>
          <option value="en">English</option>
        </select>
        <div class="title-block">
          <h1>Font2SVG - Text to SVG Converter</h1>
          <p class="help">
            指定されたフォント・文字からSVGを生成します。
          </p>
        </div>
        <div class="header-actions">
          <a class="x-link" href="https://x.com/MugLab3" target="_blank" rel="noopener noreferrer">
            <img src="https://unavatar.io/github/mug-lab-3" alt="MugLab3 icon" />
            Mug on X
          </a>
          <span id="version"></span>
        </div>
      </div>
    </header>

    <section class="card">
      <div class="row">
        <label class="inline" for="localList">
          <span class="material-symbols-outlined" aria-hidden="true">font_download</span>
          <span>フォント</span>
        </label>
        <div class="fontControls">
          <div class="switcher">
            <div id="fontButtonWrap" class="switchItem is-active">
              <button id="btnListLocal" class="btn"><span class="material-symbols-outlined">font_download</span>
                フォント読み込み</button>
            </div>
            <div id="fontListWrap" class="switchItem">
              <select id="localList"></select>
            </div>
          </div>
          <select id="styleList" class="styleSelect is-hidden" disabled aria-label="スタイル"></select>
        </div>
      </div>

      <div class="row">
        <label class="inline" for="text">
          <span class="material-symbols-outlined" aria-hidden="true">text_fields</span>
          <span>テキスト</span>
        </label>
        <textarea id="text">ABC123!%$漢字ひらカナ。</textarea>
      </div>
      <div class="row">
        <label class="inline" for="color">
          <span class="material-symbols-outlined" aria-hidden="true">palette</span>
          <span>文字色</span>
          <input id="color" type="color" value="#ffffff" />
        </label>
        <label class="inline" for="mode">
          <span class="material-symbols-outlined" aria-hidden="true">format_paint</span>
          <span>描画モード</span>
          <select id="mode">
            <option value="solid">塗り</option>
            <option value="stroke">輪郭線</option>
          </select>
        </label>
        <label class="inline" for="strokeW">
          <span class="material-symbols-outlined" aria-hidden="true">line_weight</span>
          <span>線幅</span>
          <div class="number-input-wrapper">
            <input id="strokeW" type="number" value="5" min="0.5" step="0.5" />
            <div class="spin-buttons">
              <button type="button" class="spin-up">▲</button>
              <button type="button" class="spin-down">▼</button>
            </div>
          </div>
          <span>px</span>
        </label>
      </div>
    </section>

    <section class="card">
      <div class="row" style="margin-bottom:10px">
        <button id="btnDlAll" class="btn" disabled title="全SVGをZIPで一括ダウンロード" aria-label="全SVGをZIPで一括ダウンロード"
          data-i18n-label-ja="全SVG一括ダウンロード（ZIP）" data-i18n-label-en="Download All SVGs (ZIP)">
          全SVG一括ダウンロード（ZIP）
        </button>
      </div>
      <div id="preview" class="preview">
        <div id="previewScroll" class="preview-scroll">
          <div class="help">ここに各文字のSVGを表示します。</div>
        </div>
      </div>
    </section>
  </div>

  <div id="loading" class="loadingOverlay" role="alert" aria-live="polite">
    <div class="loadingPanel">
      <div class="spinner" aria-hidden="true">
        <svg viewBox="0 0 50 50" role="img" aria-label="loading">
          <circle cx="25" cy="25" r="20" pathLength="100"></circle>
        </svg>
      </div>
      <div class="loadingText">
        <div id="loadingMsg">処理中です…</div>
        <div id="loadingPct"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
    (function () {
      const $ = id => document.getElementById(id);

      const elListBtn = $("btnListLocal");
      const elList = $("localList");
      const elStyleList = $("styleList");
      const elFontName = $("fontName");
      const elSupport = $("supportNote");
      const elFontButtonWrap = $("fontButtonWrap");
      const elListWrap = $("fontListWrap");

      const elText = $("text");
      const elMode = $("mode");
      const elStrokeW = $("strokeW");
      const elColor = $("color");

      const elSpinUp = elStrokeW.parentElement.querySelector('.spin-up');
      const elSpinDown = elStrokeW.parentElement.querySelector('.spin-down');

      elSpinUp.addEventListener('click', () => {
        elStrokeW.stepUp();
        elStrokeW.dispatchEvent(new Event('input', { bubbles: true }));
      });

      elSpinDown.addEventListener('click', () => {
        elStrokeW.stepDown();
        elStrokeW.dispatchEvent(new Event('input', { bubbles: true }));
      });

      const elPreview = $("preview");
      const elPreviewScroll = $("previewScroll");
      const elDlAll = $("btnDlAll");
      const rootEl = document.documentElement;

      const PREVIEW_MIN_HEIGHT = 240;
      const PREVIEW_BOTTOM_GAP = 24;

      const parsePx = value => {
        const num = parseFloat(value);
        return Number.isFinite(num) ? num : 0;
      };


      function parseHexColor(hex) {
        if (typeof hex !== 'string') return null;
        const match = hex.trim().match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
        if (!match) return null;
        let value = match[1];
        if (value.length === 3) {
          value = value.split('').map(ch => ch + ch).join('');
        }
        const intValue = parseInt(value, 16);
        return {
          r: (intValue >> 16) & 255,
          g: (intValue >> 8) & 255,
          b: intValue & 255,
        };
      }

      function relativeLuminance(rgb) {
        if (!rgb) return NaN;
        const toLinear = c => {
          const v = c / 255;
          return v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        };
        const r = toLinear(rgb.r);
        const g = toLinear(rgb.g);
        const b = toLinear(rgb.b);
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
      }

      function contrastRatio(l1, l2) {
        if (!Number.isFinite(l1) || !Number.isFinite(l2)) return 1;
        const [hi, lo] = l1 >= l2 ? [l1, l2] : [l2, l1];
        return (hi + 0.05) / (lo + 0.05);
      }

      const checkerProfiles = {
        dark: { base: '#10151f', overlay: 'rgba(255, 255, 255, .12)' },
        light: { base: '#d8dbe5', overlay: 'rgba(0, 0, 0, .08)' },
      };
      const luminanceCache = new Map();

      function luminanceFromHex(hex) {
        if (!hex) return NaN;
        if (luminanceCache.has(hex)) {
          return luminanceCache.get(hex);
        }
        const rgb = parseHexColor(hex);
        if (!rgb) return NaN;
        const value = relativeLuminance(rgb);
        luminanceCache.set(hex, value);
        return value;
      }

      function computeCheckerColors(hex) {
        const rgb = parseHexColor(hex);
        if (!rgb) return checkerProfiles.dark;
        const textLum = relativeLuminance(rgb);
        const darkLum = luminanceFromHex(checkerProfiles.dark.base);
        const lightLum = luminanceFromHex(checkerProfiles.light.base);
        const darkContrast = contrastRatio(textLum, darkLum);
        const lightContrast = contrastRatio(textLum, lightLum);
        return darkContrast >= lightContrast ? checkerProfiles.dark : checkerProfiles.light;
      }

      function computeBottomSpacing(node) {
        let total = 0;
        for (let current = node.parentElement; current && current !== document.body; current = current.parentElement) {
          const style = window.getComputedStyle(current);
          total += parsePx(style.paddingBottom) + parsePx(style.borderBottomWidth) + parsePx(style.marginBottom);
        }
        return total;
      }

      let isCompactLayout = false;

      function setCompactLayout(next) {
        if (isCompactLayout === next) return false;
        isCompactLayout = next;
        rootEl.classList.toggle('preview-compact', next);
        return true;
      }

      function applyPreviewHeight() {
        const rect = elPreview.getBoundingClientRect();
        const bottomSpacing = computeBottomSpacing(elPreview);
        const available = Math.max(0, window.innerHeight - rect.top - PREVIEW_BOTTOM_GAP - bottomSpacing);
        const maxHeight = Math.max(PREVIEW_MIN_HEIGHT, window.innerHeight - PREVIEW_BOTTOM_GAP);
        const height = Math.max(PREVIEW_MIN_HEIGHT, Math.min(maxHeight, available));
        elPreview.style.height = `${height}px`;
        elPreview.style.maxHeight = `${height}px`;
        if (elPreviewScroll) {
          elPreviewScroll.style.height = '100%';
          elPreviewScroll.style.maxHeight = '100%';
        }
        return height;
      }

      function updatePreviewHeight() {
        if (!elPreview) return;

        setCompactLayout(false);
        applyPreviewHeight();

        const rect = elPreview.getBoundingClientRect();
        const gap = window.innerHeight - rect.bottom;
        if (gap > PREVIEW_BOTTOM_GAP + 32) {
          const changed = setCompactLayout(true);
          if (changed) {
            applyPreviewHeight();
          }
        }
      }

      const MIN_PREVIEW_LOADING_MS = 240;
      let previewLoadingActive = false;
      let previewLoadingSince = 0;

      const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

      function showPreviewLoading(message = 'SVG を生成しています…') {
        if (!elPreviewScroll) return;
        previewLoadingActive = true;
        previewLoadingSince = now();
        elPreviewScroll.classList.add('is-loading');
        const msg = document.createElement('div');
        msg.className = 'preview-loading';
        msg.textContent = message;
        elPreviewScroll.replaceChildren(msg);
        updatePreviewHeight();
      }

      async function ensurePreviewLoadingDuration() {
        if (!previewLoadingActive) return;
        const elapsed = now() - previewLoadingSince;
        if (elapsed < MIN_PREVIEW_LOADING_MS) {
          await new Promise(resolve => setTimeout(resolve, MIN_PREVIEW_LOADING_MS - elapsed));
        }
      }

      function clearPreviewLoading() {
        previewLoadingActive = false;
        if (elPreviewScroll) {
          elPreviewScroll.classList.remove('is-loading');
        }
      }

      function showPreviewPlaceholder() {
        if (!elPreviewScroll) return;
        clearPreviewLoading();
        const msg = document.createElement('div');
        msg.className = 'help';
        msg.textContent = 'ここに各文字のSVGを表示します。';
        elPreviewScroll.replaceChildren(msg);
        updatePreviewHeight();
      }

      const PREVIEW_SIZE = 300;
      const PREVIEW_HEIGHT = 220;
      const OUTPUT_SIZE = 481;
      const PRECISION = 3;

      const WEIGHT_NAME_BY_CLASS = {
        100: 'Thin',
        200: 'Extra Light',
        300: 'Light',
        400: 'Regular',
        500: 'Medium',
        600: 'Semi Bold',
        700: 'Bold',
        800: 'Extra Bold',
        900: 'Black',
      };

      const loadBufferCache = new WeakMap();
      const fontFacePromiseCache = new WeakMap();
      const fontParseCache = new WeakMap();
      const previewFamilyNameMap = new Map();
      let previewFamilyCounter = 0;

      const JA_LOCALES = ['ja', 'ja-JP', 'ja_JP'];
      const EN_LOCALES = ['en', 'en-US', 'en-GB'];

      let fontFamilies = [];
      let otFont = null;
      let isSwitchingFont = false;
      let currentFontName = '';
      let autoGenTimer = null;

      function queueGenerate(opts = {}) {
        const { instant = false, delay = 150 } = opts;
        if (!otFont || isSwitchingFont) return;
        if (autoGenTimer) {
          clearTimeout(autoGenTimer);
          autoGenTimer = null;
        }
        const wait = Math.max(0, delay);
        autoGenTimer = setTimeout(() => {
          autoGenTimer = null;
          void generateAll({ instant });
        }, wait);
      }

      const supportLocal = typeof window.queryLocalFonts === 'function';
      if (!supportLocal) {
        elListBtn.disabled = true;
        if (elSupport) {
          elSupport.textContent = 'この環境では Local Font Access を利用できません。Chromium系ブラウザをご利用ください。';
        }
      }

      const elLang = $("lang");

      elColor.addEventListener('input', () => {
        queueGenerate({ instant: true, delay: 0 });
      });
      elMode.addEventListener('change', () => {
        queueGenerate({ instant: true, delay: 0 });
      });
      elStrokeW.addEventListener('input', () => {
        queueGenerate({ instant: true, delay: 0 });
      });
      elText.addEventListener('input', () => {
        queueGenerate({ instant: false, delay: 250 });
      });

      function toggleFontControls(showList) {
        if (!elFontButtonWrap || !elListWrap) return;
        if (showList) {
          elFontButtonWrap.classList.remove('is-active');
          elListWrap.classList.add('is-active');
        } else {
          elListWrap.classList.remove('is-active');
          elFontButtonWrap.classList.add('is-active');
        }
      }

      function resetStyleSelect() {
        if (!elStyleList) return;
        elStyleList.innerHTML = '';
        elStyleList.value = '';
        elStyleList.disabled = true;
        elStyleList.classList.add('is-hidden');
      }

      function updateStyleDisabledState(family) {
        if (!elStyleList) return;
        const hasVariants = !!(family && Array.isArray(family.variants) && family.variants.length > 0);
        elStyleList.disabled = !hasVariants;
        elStyleList.classList.toggle('is-hidden', !hasVariants);
      }

      function assignOptionFont(option, variant) {
        if (!option || !variant) return;
        if (Number.isFinite(variant.weightValue)) {
          option.dataset.weightClass = String(variant.weightValue);
        } else {
          delete option.dataset.weightClass;
        }
        if (variant.styleName) {
          option.dataset.styleName = variant.styleName;
        } else {
          delete option.dataset.styleName;
        }
      }

      function sanitizeStyleText(text) {
        if (!text) return '';
        return String(text).replace(/[_-]+/g, ' ').replace(/\s+/g, ' ').trim();
      }

      function titleCase(text) {
        return String(text).replace(/(^|\s)(\S)/g, (m, p1, p2) => p1 + p2.toUpperCase());
      }

      function snapWeightValue(weight) {
        if (!Number.isFinite(weight)) return NaN;
        const clamped = Math.min(900, Math.max(100, weight));
        const snapped = Math.round(clamped / 100) * 100;
        return Math.min(900, Math.max(100, snapped));
      }

      function weightNameFromValue(weight) {
        const snapped = snapWeightValue(weight);
        return Number.isFinite(snapped) ? (WEIGHT_NAME_BY_CLASS[snapped] || '') : '';
      }

      async function ensureParsedFont(variant) {
        if (!variant) return null;
        if (!fontParseCache.has(variant)) {
          const promise = (async () => {
            const buffer = await loadVariantBuffer(variant);
            if (!buffer) return null;
            return opentype.parse(buffer);
          })();
          fontParseCache.set(variant, promise);
        }
        try {
          return await fontParseCache.get(variant);
        } catch (err) {
          fontParseCache.delete(variant);
          throw err;
        }
      }

      function pickNameFromTable(table, localeOrder, fallback = '') {
        if (!table) return fallback;
        for (const locale of localeOrder) {
          if (table[locale]) return table[locale];
          const alt = locale.replace('-', '_');
          if (table[alt]) return table[alt];
        }
        const values = Object.values(table);
        if (values.length > 0) {
          return values[0];
        }
        return fallback;
      }

      function extractFamilyNameFromFont(font, localeOrder, fallback) {
        if (!font || !font.names) return sanitizeStyleText(fallback || '');
        const names = font.names;
        const sources = [names.preferredFamily, names.fontFamily, names.family, names.fullName];
        for (const src of sources) {
          const picked = pickNameFromTable(src, localeOrder);
          if (picked) return sanitizeStyleText(picked);
        }
        for (const src of sources) {
          if (!src) continue;
          const values = Object.values(src);
          if (values.length > 0) return sanitizeStyleText(values[0]);
        }
        return sanitizeStyleText(fallback || '');
      }

      async function enrichVariantLocaleNames(variant) {
        if (!variant || variant.hasLocalizedNames) return variant;
        try {
          const font = await ensureParsedFont(variant);
          if (font) {
            const ja = extractFamilyNameFromFont(font, JA_LOCALES, variant.familyName);
            const en = extractFamilyNameFromFont(font, EN_LOCALES, variant.familyName || ja);
            variant.familyNameJa = ja || variant.familyName;
            variant.familyNameEn = en || ja || variant.familyName;
            const primary = variant.familyNameEn || variant.familyNameJa || variant.familyName;
            if (primary) {
              variant.familyName = primary;
              variant.familyKey = primary.toLowerCase();
            }
          } else {
            variant.familyNameJa = variant.familyNameJa || variant.familyName;
            variant.familyNameEn = variant.familyNameEn || variant.familyName;
          }
        } catch (err) {
          console.error(err);
        }
        variant.hasLocalizedNames = true;
        return variant;
      }

      function getCurrentLocale() {
        if (elLang && elLang.value === 'ja') return 'ja';
        return 'en';
      }

      async function loadVariantBuffer(variant) {
        if (!variant || !variant.descriptor || typeof variant.descriptor.blob !== 'function') return null;
        if (!loadBufferCache.has(variant)) {
          const promise = (async () => {
            const blob = await variant.descriptor.blob();
            const buffer = await blob.arrayBuffer();
            variant.buffer = buffer;
            return buffer;
          })();
          loadBufferCache.set(variant, promise);
        }
        try {
          return await loadBufferCache.get(variant);
        } catch (err) {
          loadBufferCache.delete(variant);
          throw err;
        }
      }

      function ensurePreviewFamilyName(variant) {
        const key = variant.postscriptName || variant.fullName || `${variant.familyName}-${variant.styleName}-${variant.weightLabel}`;
        if (!previewFamilyNameMap.has(key)) {
          previewFamilyNameMap.set(key, `__lf_${++previewFamilyCounter}`);
        }
        const name = previewFamilyNameMap.get(key);
        variant.fontFaceFamily = name;
        return name;
      }

      async function ensureFontFaceForVariant(variant) {
        if (!variant || typeof window.FontFace !== 'function') return null;
        if (variant.fontFaceFamily && document.fonts && document.fonts.check(`1em ${quoteFontFamily(variant.fontFaceFamily)}`)) {
          return variant.fontFaceFamily;
        }
        if (!fontFacePromiseCache.has(variant)) {
          const promise = (async () => {
            const buffer = await loadVariantBuffer(variant);
            if (!buffer) return null;
            const familyName = ensurePreviewFamilyName(variant);
            const source = new Uint8Array(buffer);
            const fontFace = new FontFace(familyName, source);
            await fontFace.load();
            document.fonts.add(fontFace);
            return fontFace.family || familyName;
          })();
          fontFacePromiseCache.set(variant, promise);
        }
        try {
          const loadedFamily = await fontFacePromiseCache.get(variant);
          if (loadedFamily) {
            variant.fontFaceFamily = loadedFamily;
          }
          return loadedFamily;
        } catch (err) {
          fontFacePromiseCache.delete(variant);
          console.error(err);
          return null;
        }
      }

      function applyOptionPreview(option, variant) {
        if (!option || !variant) return;
        const family = variant.fontFaceFamily || variant.familyName;
        if (family) {
          const stack = variant.fontFaceFamily ? `${quoteFontFamily(variant.fontFaceFamily)}, ${quoteFontFamily(variant.familyName) || 'sans-serif'}` : `${quoteFontFamily(family)}, sans-serif`;
          option.style.fontFamily = stack;
        }
        option.style.fontStyle = variant.isItalic ? 'italic' : (variant.isOblique ? 'oblique' : 'normal');
        const weight = snapWeightValue(variant.weightValue);
        option.style.fontWeight = Number.isFinite(weight) ? String(weight) : '';
      }

      function buildVariantFromDescriptor(fd) {
        const familyName = (fd.family || fd.fullName || fd.postscriptName || 'Local Font').trim() || 'Local Font';
        const styleName = sanitizeStyleText(fd.style || '');
        const fullName = (fd.fullName || '').trim();
        const postscriptName = (fd.postscriptName || '').trim();
        const weightValue = (typeof fd.weight === 'number' && Number.isFinite(fd.weight)) ? fd.weight : NaN;
        const weightLabel = (typeof fd.weight === 'string' && fd.weight.trim()) ? fd.weight.trim() : '';
        const isItalic = /italic/i.test(styleName) || /italic/i.test(weightLabel) || /italic/i.test(fullName);
        const isOblique = !isItalic && (/oblique/i.test(styleName) || /oblique/i.test(weightLabel) || /oblique/i.test(fullName));

        const variant = {
          descriptor: fd,
          familyName,
          familyKey: familyName.toLowerCase(),
          styleName,
          fullName,
          postscriptName,
          weightValue,
          weightLabel,
          isItalic,
          isOblique,
        };
        variant.displayLabel = buildVariantLabel(variant);
        return variant;
      }

      function buildVariantLabel(variant) {
        if (!variant) return 'Regular';
        const parts = [];
        const pushUnique = (label) => {
          if (!label) return;
          const normalized = label.trim();
          if (!normalized) return;
          const lower = normalized.toLowerCase();
          if (!parts.some(p => p.toLowerCase() === lower)) {
            parts.push(normalized);
          }
        };

        const styleTokens = sanitizeStyleText(variant.styleName).split(' ').filter(Boolean);
        styleTokens.forEach(token => {
          const lower = token.toLowerCase();
          if (lower === 'regular' || lower === 'normal' || lower === 'plain') return;
          if (lower === 'italic' || lower === 'oblique') return;
          pushUnique(titleCase(token));
        });

        const weightFromValue = weightNameFromValue(variant.weightValue);
        if (weightFromValue && weightFromValue.toLowerCase() !== 'regular') {
          pushUnique(weightFromValue);
        } else if (variant.weightLabel) {
          const cleaned = titleCase(sanitizeStyleText(variant.weightLabel));
          if (cleaned && cleaned.toLowerCase() !== 'regular') {
            pushUnique(cleaned);
          }
        }

        if (variant.isItalic) {
          pushUnique('Italic');
        } else if (variant.isOblique) {
          pushUnique('Oblique');
        }

        if (parts.length === 0) {
          const fallbackWeight = weightNameFromValue(variant.weightValue);
          if (fallbackWeight) {
            pushUnique(fallbackWeight);
          }
        }

        if (parts.length === 0) {
          const family = variant.familyName || '';
          const full = variant.fullName || variant.postscriptName || '';
          if (full) {
            const familyLower = family.toLowerCase();
            const fullLower = full.toLowerCase();
            if (family && fullLower.startsWith(familyLower)) {
              const remainder = sanitizeStyleText(full.slice(family.length));
              if (remainder) {
                pushUnique(titleCase(remainder));
              }
            } else {
              pushUnique(titleCase(sanitizeStyleText(full)));
            }
          }
        }

        if (parts.length === 0) {
          pushUnique('Regular');
        }

        return parts.join(' ');
      }

      function prepareFamilyEntries(records) {
        const byFamily = new Map();
        for (const variant of records) {
          const familyKey = variant.familyKey || (variant.familyName || 'Local Font').toLowerCase();
          const baseName = variant.familyName || variant.familyNameEn || variant.familyNameJa || 'Local Font';
          if (!byFamily.has(familyKey)) {
            byFamily.set(familyKey, {
              key: familyKey,
              baseName,
              nameEn: variant.familyNameEn || '',
              nameJa: variant.familyNameJa || '',
              variants: [],
            });
          }
          const entry = byFamily.get(familyKey);
          entry.variants.push(variant);
          if (variant.familyNameEn && !entry.nameEn) entry.nameEn = variant.familyNameEn;
          if (variant.familyNameJa && !entry.nameJa) entry.nameJa = variant.familyNameJa;
          if (!entry.baseName) entry.baseName = baseName;
        }
        const entries = Array.from(byFamily.values());
        entries.forEach(entry => {
          entry.variants.sort((a, b) => {
            const weightA = snapWeightValue(a.weightValue);
            const weightB = snapWeightValue(b.weightValue);
            if (Number.isFinite(weightA) && Number.isFinite(weightB) && weightA !== weightB) {
              return weightA - weightB;
            }
            const styleA = (a.displayLabel || a.styleName || '').toLowerCase();
            const styleB = (b.displayLabel || b.styleName || '').toLowerCase();
            if (styleA !== styleB) return styleA.localeCompare(styleB);
            const fullNameA = (a.fullName || '').toLowerCase();
            const fullNameB = (b.fullName || '').toLowerCase();
            return fullNameA.localeCompare(fullNameB);
          });
        });
        entries.sort((a, b) => {
          const nameA = (a.nameEn || a.baseName || '').toLowerCase();
          const nameB = (b.nameEn || b.baseName || '').toLowerCase();
          return nameA.localeCompare(nameB);
        });
        return entries;
      }

      function getSelectedFamily() {
        if (!elList) return null;
        const value = elList.value;
        if (value === '' || value == null) return null;
        const idx = Number(value);
        if (!Number.isInteger(idx) || idx < 0 || idx >= fontFamilies.length) return null;
        return fontFamilies[idx] || null;
      }

      async function switchFontDescriptor(variant) {
        if (!variant || isSwitchingFont) return;
        isSwitchingFont = true;
        if (autoGenTimer) {
          clearTimeout(autoGenTimer);
          autoGenTimer = null;
        }
        if (elDlAll) {
          elDlAll.disabled = true;
          elDlAll.onclick = null;
        }
        showPreviewLoading('SVG を生成しています…');
        if (elList) elList.disabled = true;
        if (elStyleList) elStyleList.disabled = true;
        try {
          const font = await ensureParsedFont(variant);
          if (font) {
            otFont = font;
          } else {
            const buffer = await loadVariantBuffer(variant);
            otFont = buffer ? opentype.parse(buffer) : null;
          }
          const fd = variant.descriptor;
          const resolvedName = variant.fullName || variant.postscriptName || fd.fullName || fd.postscriptName || `${variant.familyName || ''} ${variant.styleName || ''}`.trim() || 'Local Font';
          if (elFontName) elFontName.textContent = resolvedName;
          currentFontName = resolvedName;
          await generateAll({ instant: false });
        } catch (err) {
          console.error(err);
        } finally {
          if (elList) elList.disabled = false;
          updateStyleDisabledState(getSelectedFamily());
          isSwitchingFont = false;
        }
      }

      function populateStyleSelect(family) {
        if (!elStyleList) return;
        resetStyleSelect();
        if (!family || !Array.isArray(family.variants) || family.variants.length === 0) {
          updateStyleDisabledState(null);
          return;
        }
        const frag = document.createDocumentFragment();
        family.variants.forEach((variant, index) => {
          const option = document.createElement('option');
          option.value = String(index);
          const label = variant.displayLabel || buildVariantLabel(variant);
          option.textContent = label;
          assignOptionFont(option, variant);
          frag.appendChild(option);
        });
        elStyleList.appendChild(frag);
        updateStyleDisabledState(family);
        // --- Regular 優先選択ロジック ---
        // 条件: Italic/Oblique でない かつ weight が 400 相当、またはラベルが 'Regular'
        let regularIndex = -1;
        for (let i = 0; i < family.variants.length; i++) {
          const v = family.variants[i];
          const snapped = snapWeightValue(v.weightValue);
          const label = (v.displayLabel || buildVariantLabel(v) || '').toLowerCase();
          const isRegularWeight = snapped === 400 || /\b400\b/.test(String(v.weightLabel));
          const explicitRegular = label === 'regular' || /regular/i.test(v.styleName || '') || /regular/i.test(v.weightLabel || '');
          if (!v.isItalic && !v.isOblique && (explicitRegular || isRegularWeight)) {
            regularIndex = i;
            break;
          }
        }
        if (regularIndex < 0) regularIndex = 0; // フォールバック
        elStyleList.selectedIndex = regularIndex;
        void switchFontDescriptor(family.variants[regularIndex]);
      }

      function updateFamilyDisplayNames() {
        const locale = getCurrentLocale();
        fontFamilies.forEach(family => {
          const fallback = family.nameEn || family.nameJa || family.baseName || (family.variants[0] && family.variants[0].familyName) || 'Local Font';
          if (locale === 'ja') {
            family.displayName = family.nameJa || fallback;
          } else {
            family.displayName = family.nameEn || fallback;
          }
        });
      }

      function applyFamilyOptionLabels() {
        if (!elList) return;
        fontFamilies.forEach((family, index) => {
          const option = elList.options[index];
          if (option) {
            option.textContent = family.displayName || family.baseName || family.nameEn || family.nameJa || 'Local Font';
          }
        });
      }

      function handleFamilyChange() {
        if (isSwitchingFont) return;
        const family = getSelectedFamily();
        populateStyleSelect(family);
      }

      async function handleStyleChange() {
        if (!elStyleList || isSwitchingFont) return;
        const value = elStyleList.value;
        if (value === '' || value == null) {
          otFont = null;
          currentFontName = '';
          showPreviewPlaceholder();
          if (elDlAll) {
            elDlAll.disabled = true;
            elDlAll.onclick = null;
          }
          return;
        }
        const family = getSelectedFamily();
        if (!family) return;
        const variantIdx = Number(value);
        if (!Number.isInteger(variantIdx) || variantIdx < 0 || variantIdx >= family.variants.length) return;
        await switchFontDescriptor(family.variants[variantIdx]);
      }

      if (elList) {
        elList.addEventListener('change', handleFamilyChange);
      }
      if (elStyleList) {
        elStyleList.addEventListener('change', () => { void handleStyleChange(); });
      }
      if (elLang) {
        elLang.addEventListener('change', () => {
          updateFamilyDisplayNames();
          applyFamilyOptionLabels();
        });
      }
      resetStyleSelect();

      // ファイル名の危険文字を安全化
      function safeName(s) {
        return String(s ?? 'LocalFont').replace(/[\\/:*?"<>|\r\n]/g, '_').trim() || 'LocalFont';
      }

      function isCollectionBuffer(buf) {
        if (!buf || buf.byteLength < 4) return false;
        const u8 = new Uint8Array(buf, 0, 4);
        const head = String.fromCharCode(u8[0], u8[1], u8[2], u8[3]).toLowerCase();
        return head === 'ttcf';
      }

      const showLoading = (msg) => {
        const el = document.getElementById('loading');
        const msgEl = document.getElementById('loadingMsg');
        const pctEl = document.getElementById('loadingPct');
        if (el) {
          el.classList.add('show');
          if (msgEl) msgEl.textContent = msg || '処理中です…';
          if (pctEl) pctEl.textContent = '';
        }
      };
      const updateLoadingProgress = (current, total) => {
        const pctEl = document.getElementById('loadingPct');
        if (pctEl && total > 0) {
          const pct = Math.floor((current / total) * 100);
          pctEl.textContent = `${current}/${total} (${pct}%)`;
        }
      };
      const hideLoading = () => {
        const el = document.getElementById('loading');
        const pctEl = document.getElementById('loadingPct');
        if (el) el.classList.remove('show');
        if (pctEl) pctEl.textContent = '';
      };

      elListBtn.addEventListener('click', async () => {
        if (!supportLocal) return;
        try {
          elListBtn.disabled = true;
          showLoading('フォントを読み込んでいます…');
          resetStyleSelect();

          const fonts = await window.queryLocalFonts();
          const seen = new Set();
          const unique = [];
          for (const f of fonts) {
            const key = f.postscriptName || f.fullName || (f.family + ':' + (f.style || ''));
            if (!seen.has(key)) { seen.add(key); unique.push(f); }
          }
          unique.sort((a, b) => (a.fullName || a.family).localeCompare(b.fullName || b.family));

          const variants = [];
          updateLoadingProgress(0, unique.length);
          for (let i = 0; i < unique.length; i++) {
            const fd = unique[i];
            try {
              const blob = await fd.blob();
              const headBuf = await blob.slice(0, 4).arrayBuffer();
              if (isCollectionBuffer(headBuf)) {
                updateLoadingProgress(i + 1, unique.length);
                continue;
              }
              const variant = buildVariantFromDescriptor(fd);
              const buffer = await blob.arrayBuffer();
              variant.buffer = buffer;
              // enrich locale names
              try {
                const font = opentype.parse(buffer);
                const ja = extractFamilyNameFromFont(font, JA_LOCALES, variant.familyName);
                const en = extractFamilyNameFromFont(font, EN_LOCALES, variant.familyName || ja);
                variant.familyNameJa = ja || variant.familyName;
                variant.familyNameEn = en || ja || variant.familyName;
                const primary = variant.familyNameEn || variant.familyNameJa || variant.familyName;
                if (primary) {
                  variant.familyName = primary;
                  variant.familyKey = primary.toLowerCase();
                }
              } catch (e) {
                console.error(e);
                variant.familyNameJa = variant.familyName;
                variant.familyNameEn = variant.familyName;
              }
              variant.hasLocalizedNames = true;
              // FontFace
              const familyName = ensurePreviewFamilyName(variant);
              const source = new Uint8Array(buffer);
              const fontFace = new FontFace(familyName, source);
              await fontFace.load();
              document.fonts.add(fontFace);
              variant.fontFaceFamily = fontFace.family || familyName;
              variants.push(variant);
            } catch (e) {
              console.error(e);
            } finally {
              updateLoadingProgress(i + 1, unique.length);
            }
          }

          fontFamilies = prepareFamilyEntries(variants);
          updateFamilyDisplayNames();

          if (!fontFamilies.length) {
            toggleFontControls(false);
            updateStyleDisabledState(null);
            return;
          }

          elList.innerHTML = '';
          const frag = document.createDocumentFragment();

          fontFamilies.forEach((family, index) => {
            const option = document.createElement('option');
            option.value = String(index);
            option.textContent = family.displayName || family.baseName || family.nameEn || family.nameJa;
            if (family.variants[0]) assignOptionFont(option, family.variants[0]);
            frag.appendChild(option);
          });

          elList.appendChild(frag);
          toggleFontControls(true);
          resetStyleSelect();
          updateStyleDisabledState(null);

          if (fontFamilies.length > 0) {
            elList.selectedIndex = 0;
            handleFamilyChange();
          }

          applyFamilyOptionLabels();

          requestAnimationFrame(() => {
            try { elList.focus({ preventScroll: true }); }
            catch (_) { try { elList.focus(); } catch (__) { } }
          });

          fontFamilies.forEach((family, index) => {
            const option = elList.options[index];
            const previewVariant = family.variants && family.variants[0];
            if (!option || !previewVariant) return;
            applyOptionPreview(option, previewVariant);
          });
        } catch (err) {
          console.error(err);
        } finally {
          hideLoading();
          elListBtn.disabled = false;
        }
      });

      // 文字→SVG
      function buildSVGForChar(font, ch, opts) {
        const { sizePx, precision, mode, strokeWidth, color } = opts;
        const scale = sizePx / font.unitsPerEm;
        const glyph = font.charToGlyph ? font.charToGlyph(ch) : font.stringToGlyphs(ch)[0];

        // 固定サイズの viewBox を用意し、文字位置のみ調整する
        const m = sizePx * 0.08; // マージン
        const width = Math.ceil(font.unitsPerEm * scale + 2 * m);
        const height = Math.ceil((font.ascender - font.descender) * scale + 2 * m);

        // 描画パスを取得（ベースラインをフォントアセンダ位置に合わせる）
        const gp = glyph.getPath(0, font.ascender * scale, sizePx);
        const d = gp.toPathData(precision);

        // バウンディングボックスから横方向のみ平行移動量を算出（縦方向はベースライン基準で揃える）
        let tx = m, ty = m;
        if (typeof gp.getBoundingBox === 'function') {
          const bb = gp.getBoundingBox();
          const glyphW = bb.x2 - bb.x1;
          tx = (width - glyphW) / 2 - bb.x1;
          // ty はベースラインを共通に保つため一定値とする
        }

        const style = (mode === 'solid') ? `fill: ${color};` : `fill: none; stroke: ${color}; stroke-width: ${strokeWidth};`;
        const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${sizePx}" height="${sizePx}" viewBox="0 0 ${width} ${height}">\n  <g style="${style}">\n    <path d="${d}" transform="translate(${tx},${ty})"/>\n  </g>\n</svg>`;
        return svg;
      }

      // テキスト全体 → SVG
      function buildSVGForText(text, opts) {
        if (!otFont) return '';
        const { sizePx, precision, mode, strokeWidth, color } = opts;
        const scale = sizePx / otFont.unitsPerEm;
        const m = sizePx * 0.08; // マージン

        const lineHeight = (otFont.ascender - otFont.descender) * scale;
        const lines = String(text).replace(/\r\n?/g, '\n').split('\n');
        const fullPath = new opentype.Path();
        let width = 0;
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const p = otFont.getPath(line, 0, otFont.ascender * scale + i * lineHeight, sizePx);
          fullPath.commands.push(...p.commands);
          width = Math.max(width, otFont.getAdvanceWidth(line, sizePx));
        }
        const d = fullPath.toPathData(precision);

        width = Math.ceil(width + 2 * m);
        const height = Math.ceil(lineHeight * lines.length + 2 * m);

        let tx = m, ty = m;
        if (typeof fullPath.getBoundingBox === 'function') {
          const bb = fullPath.getBoundingBox();
          tx = m - bb.x1;
          ty = m - bb.y1;
        }

        const style = (mode === 'solid') ? `fill: ${color};` : `fill: none; stroke: ${color}; stroke-width: ${strokeWidth};`;
        const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">\n  <g style="${style}">\n    <path d="${d}" transform="translate(${tx},${ty})"/>\n  </g>\n</svg>`;
        return svg;
      }

      function escapeHtml(s) { return String(s).replace(/[&<>"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', '\'': '&#39;' }[c])); }

      function quoteFontFamily(name) {
        if (!name) return '';
        const text = String(name).trim();
        if (!text) return '';
        return '"' + text.replace(/"/g, '\\"') + '"';
      }

      function* iterCharsIgnoringNewlines(str) {
        const noNL = String(str).replace(/\r\n?/g, '\n').replace(/\n/g, '');
        for (const ch of Array.from(noNL)) yield ch;
      }

      // タイル（個別ダウンロード名に 0 埋め連番を付与）
      function makeTile(char, svg, idx, pad, checkerColors) {
        const tile = document.createElement('div');
        tile.className = 'tile';
        const box = document.createElement('div');
        box.className = 'box';
        if (checkerColors && checkerColors.base && checkerColors.overlay) {
          box.style.setProperty('--checker-base', checkerColors.base);
          box.style.setProperty('--checker-overlay', checkerColors.overlay);
        }
        box.innerHTML = svg;
        const svgEl = box.querySelector('svg');
        if (svgEl) {
          svgEl.setAttribute('width', PREVIEW_SIZE);
          svgEl.setAttribute('height', PREVIEW_HEIGHT);
        }
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.innerHTML = `<span>#${idx + 1}「${escapeHtml(char)}」</span>`;
        const btn = document.createElement('button');
        btn.className = 'btn char-dl-btn';
        btn.innerHTML = '<span class="material-symbols-outlined">download</span> SVG';
        btn.addEventListener('click', () => {
          const a = document.createElement('a');
          a.href = URL.createObjectURL(new Blob([svg], { type: 'image/svg+xml' }));
          a.download = `N${pad(idx + 1)}_${safeName(char)}.svg`;
          a.click();
          URL.revokeObjectURL(a.href);
        });
        const foot = document.createElement('div');
        foot.className = 'foot';
        foot.appendChild(meta); foot.appendChild(btn);
        tile.appendChild(box); tile.appendChild(foot);
        return tile;
      }

      // 生成（1文字ずつ）
      async function generateAll(opts = {}) {
        const { instant = false } = opts;
        if (!otFont) { return; }
        const sizePx = OUTPUT_SIZE;
        const precision = PRECISION;
        const mode = elMode.value; const strokeWidth = Number(elStrokeW.value);
        const color = elColor.value;
        const checkerColors = computeCheckerColors(color);
        const skipSpace = true;

        elDlAll.disabled = true;
        elDlAll.onclick = null;
        if (!instant) {
          showPreviewLoading();
          await new Promise(r => requestAnimationFrame(r));
        } else {
          clearPreviewLoading();
        }
        const grid = document.createElement('div');
        grid.className = 'grid';

        const chars = [];
        for (const ch of iterCharsIgnoringNewlines(elText.value)) {
          if (skipSpace && /^\s$/.test(ch)) continue;
          chars.push(ch);
        }
        if (chars.length === 0) {
          await ensurePreviewLoadingDuration();
          showPreviewPlaceholder();
          return;
        }

        // 0埋め関数：総数の桁数に合わせる
        const total = chars.length;
        const width = String(total).length;
        const pad = n => String(n).padStart(width, '0');

        const svgs = [];
        for (let i = 0; i < chars.length; i++) {
          const ch = chars[i];
          try {
            const svg = buildSVGForChar(otFont, ch, { sizePx, precision, mode, strokeWidth, color });
            svgs.push({ ch, svg });
            grid.appendChild(makeTile(ch, svg, i, pad, checkerColors));
          } catch (err) { console.error(err); }
        }
        const fullTextSvg = buildSVGForText(elText.value, { sizePx, precision, mode, strokeWidth, color });

        await ensurePreviewLoadingDuration();
        clearPreviewLoading();
        if (elPreviewScroll) {
          elPreviewScroll.replaceChildren(grid);
        }
        updatePreviewHeight();
        elDlAll.disabled = false;

        // 一括ZIP
        elDlAll.onclick = async () => {
          if (!window.JSZip) { alert('JSZip を読み込めませんでした。'); return; }
          const zip = new JSZip();
          for (let i = 0; i < svgs.length; i++) {
            const { ch, svg } = svgs[i];
            zip.file(`N${pad(i + 1)}_${safeName(ch)}.svg`, svg);
          }
          zip.file('full_text.svg', fullTextSvg);
          const blob = await zip.generateAsync({ type: 'blob' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);

          // ZIP名：日時とフォント名（安全化、空白はハイフンに変換）を付与
          const dt = new Date();
          const y = dt.getFullYear();
          const m = String(dt.getMonth() + 1).padStart(2, '0');
          const d = String(dt.getDate()).padStart(2, '0');
          const hh = String(dt.getHours()).padStart(2, '0');
          const mm = String(dt.getMinutes()).padStart(2, '0');
          const ss = String(dt.getSeconds()).padStart(2, '0');
          const safeFontName = safeName(currentFontName).replace(/\s+/g, '-');
          const zipName = `svgs_${y}${m}${d}-${hh}${mm}${ss}_${safeFontName}.zip`;

          a.download = zipName;
          a.click();
          URL.revokeObjectURL(a.href);
        };
      }

      window.addEventListener('resize', () => { requestAnimationFrame(updatePreviewHeight); });
      if (window.ResizeObserver) {
        const layoutRoot = document.querySelector('.wrap');
        if (layoutRoot) {
          const ro = new ResizeObserver(() => { requestAnimationFrame(updatePreviewHeight); });
          ro.observe(layoutRoot);
        }
      }
      // 初期描画: コンテンツを不可視状態で高さ計算を2回行い（compact判定を含む可能性）安定後に表示
      requestAnimationFrame(() => {
        try {
          updatePreviewHeight();
          updatePreviewHeight(); // 二度実行で compact 切替を含む場合も初期シフトを吸収
        } finally {
          document.documentElement.classList.remove('booting');
        }
      });

      // === Overlay Scrollbar 判定 ===
      (function detectOverlayScrollbars() {
        try {
          const test = document.createElement('div');
          test.style.cssText = 'position:absolute;top:-9999px;width:100px;height:100px;overflow:scroll;pointer-events:none;opacity:0;';
          const inner = document.createElement('div');
          inner.style.height = '200px';
          test.appendChild(inner);
          document.body.appendChild(test);
          const scrollbarWidth = test.offsetWidth - test.clientWidth; // 物理スクロールバー幅
          document.body.removeChild(test);
          if (scrollbarWidth <= 2) {
            // macOS の overlay 等: オフセット無効化
            document.documentElement.classList.add('overlay-scrollbars');
          }
        } catch (e) {
          console.warn('overlay scrollbar detection failed', e);
        }
      })();

    })();
  </script>
</body>

</html>