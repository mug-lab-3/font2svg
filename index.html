<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>font2svg</title>
  <style>
    :root{
      --bg: #0b0c10;
      --primary: #ac00ac;
      --accent: #AE75DA;
      --fg:#1b1648;
      --muted: #a7adbb;
      --card:#ffffff;
      --card-soft:#f3eeff;
      --ring:#dcd6ff;
      --ring-strong:#b6aef5;
      --accent-strong:#ec4899;
      --shadow:0 18px 40px rgba(72,45,154,.12);
      --panel: #151821;
      --ink: #e8eaf0;
      --chip: #222735;
    }
    *,*::before,*::after{box-sizing:border-box}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font:16px/1.7 "Inter","Hiragino Kaku Gothic ProN","Noto Sans JP",-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
    }
    .wrap{
      max-width:960px;
      margin:56px auto 64px;
      padding:0 24px 48px;
      display:grid;
      gap:28px;
    }
    header{
      text-align:center;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    h1{
      font-size:32px;
      font-weight:700;
      margin:0;
      letter-spacing:.01em;
    }
    h2{
      font-size:20px;
      font-weight:600;
      margin:0 0 14px;
      letter-spacing:.02em;
    }
    header p{
      margin:0;
      color:var(--muted);
      font-size:15px;
    }
    .card{
      background:var(--panel);
      border:1px solid var(--chip);
      border-radius:20px;
      padding:22px 24px 24px;
      box-shadow:var(--shadow);
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap:16px;
      align-items:center;
    }
    .btn{
      appearance:none;
      border:0;
      border-radius:999px;
      padding:11px 22px;
      background:linear-gradient(135deg,var(--accent),var(--accent-strong));
      color:#fff;
      font-weight:600;
      letter-spacing:.02em;
      cursor:pointer;
      transition:transform .18s ease,box-shadow .18s ease,opacity .2s ease;
      box-shadow:0 12px 26px rgba(124,58,237,.25);
    }
    .btn:hover:not([disabled]){transform:translateY(-1px);box-shadow:0 18px 32px rgba(124,58,237,.28)}
    .btn:active:not([disabled]){transform:translateY(0);box-shadow:0 12px 22px rgba(124,58,237,.22)}
    .btn[disabled]{opacity:.45;cursor:not-allowed;box-shadow:none}
    label.inline{display:inline-flex;align-items:center;gap:10px;font-weight:500;color:var(--ink)}
    select,
    textarea,
    input[type="number"],
    input[type="range"],
    input[type="checkbox"],
    input[type="color"]{
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--chip);
      background:var(--chip);
      color:var(--ink);
      font:inherit;
      transition:border-color .15s ease,box-shadow .15s ease;
      accent-color:var(--accent);
    }
    select:focus,
    textarea:focus,
    input[type="number"]:focus,
    input[type="range"]:focus,
    input[type="checkbox"]:focus,
      input[type="color"]:focus{outline:none;border-color:var(--accent);box-shadow:0 0 0 3px rgba(124,58,237,.22)}
    textarea{
      min-width:420px;
      min-height:96px;
      resize:vertical;
    }
    input[type="range"]{padding:0;background:transparent}
    input[type="color"]{padding:0;width:52px;height:38px;border-radius:12px;background:var(--chip)}
    input[type="checkbox"]{width:20px;height:20px;padding:0;border-radius:6px;background:var(--chip);border:1px solid var(--chip)}
    a{color:var(--accent-strong);text-decoration:none;font-weight:600}
    a:hover{text-decoration:underline}
    .help{color:var(--muted);font-size:13px;line-height:1.6}
    .status{font-size:14px;color:var(--muted);margin-left:12px}
    .preview{
      min-height:240px;
      border:2px dashed var(--chip);
      border-radius:20px;
      background:linear-gradient(180deg,rgba(34,39,53,.9) 0%,rgba(21,24,33,.92) 100%);
      padding:12px;
      overflow:auto;
      transition:opacity .18s ease;
      will-change:opacity;
      contain:paint;
    }
    .preview.swap-off{opacity:0}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:18px}
    .tile{
      background:var(--panel);
      border:1px solid var(--chip);
      border-radius:18px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      box-shadow:0 14px 24px rgba(12,16,28,.6);
    }
    .tile .box{
      background-image:linear-gradient(45deg,rgba(174,117,218,.16) 25%,transparent 25%,transparent 75%,rgba(174,117,218,.16) 75%,rgba(174,117,218,.16)),linear-gradient(45deg,rgba(174,117,218,.16) 25%,transparent 25%,transparent 75%,rgba(174,117,218,.16) 75%,rgba(174,117,218,.16));
      background-size:22px 22px;
      background-position:0 0,11px 11px;
      background-color:rgba(33,38,52,.7);
      border:1px solid var(--chip);
      border-radius:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height:170px;
      overflow:auto;
      padding:8px;
    }
    .tile .meta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;gap:8px}
    footer{margin-top:8px;color:var(--muted);font-size:12px;text-align:center}
    @media (max-width:720px){
      .wrap{margin:32px auto 48px;padding:0 18px 36px;gap:22px}
      h1{font-size:26px}
      h2{font-size:19px}
      textarea{min-width:100%;width:100%}
      .row{gap:12px}
      .card{padding:20px 18px}
    }

    /* Loading overlay（一覧取得時のみ使用／フェード） */
    .loadingOverlay{
      position:fixed;
      inset:0;
      background:rgba(11,12,16,.7);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1000;
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease;
    }
    .loadingOverlay.show{opacity:1;pointer-events:auto}
    .loadingPanel{
      background:var(--panel);
      border:1px solid var(--chip);
      border-radius:18px;
      padding:18px 22px;
      box-shadow:var(--shadow);
      display:flex;
      align-items:center;
      gap:14px;
    }
    .loadingText{display:flex;flex-direction:column;gap:4px}
    #loadingPct{font-size:13px;color:var(--muted);text-align:right}
    .spinner{width:26px;height:26px;border:3px solid var(--chip);border-top-color:var(--accent-strong);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>文字ごとのSVGアウトライン生成</h1>
      <p class="help">お使いの端末にインストールされているフォントを選び、入力テキスト（改行は無視）を<strong>1文字ごとに独立したSVG</strong>に変換します。処理はすべてお使いのブラウザ内で完結し、入力文字列やフォントデータが外部に送信されることはありません。</p>
    </header>

    <section class="card">
      <h2>1. フォントを選択</h2>
      <div class="row">
        <button id="btnListLocal" class="btn">ローカルフォントを表示</button>
        <select id="localList" style="min-width:360px;display:none"></select>
      </div>
      <div class="help">選択中のフォント: <b id="fontName">（未選択）</b></div>
      <p class="help">この機能は Google Chrome／Microsoft Edge／Brave などの「Chromium系」ブラウザでご利用いただけます。初回は「このサイトにパソコン内のフォントの一覧を表示してよいですか？」という確認が表示されます。<strong>［許可］</strong>を選ぶと、インストール済みフォントをメニューから選択できるようになります。</p>
      <div class="help" id="supportNote"></div>
    </section>

    <section class="card">
      <h2>2. テキストと出力設定</h2>
      <div class="row">
        <label class="inline" style="align-items:flex-start">テキスト
          <textarea id="text">ABC123!%$漢字ひらカナ。</textarea>
        </label>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="inline">文字色 <input id="color" type="color" value="#000000" /></label>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="inline">小数桁 <input id="prec" type="range" min="0" max="4" step="1" value="3"/> <span id="precVal">3</span></label>
        <label class="inline">描画モード
          <select id="mode">
            <option value="solid">塗り</option>
            <option value="stroke">輪郭線</option>
          </select>
        </label>
        <label class="inline">線幅 <input id="strokeW" type="number" value="5" min="0.5" step="0.5" style="width:80px"/> px</label>
        <label class="inline">空白を除外 <input id="skipSpace" type="checkbox" checked /></label>
      </div>
      <div style="margin-top:8px">
        <button id="btnGen" class="btn" disabled>SVGを生成</button>
        <span id="status" class="status"></span>
      </div>
    </section>

    <section class="card">
      <h2>3. プレビューと一括ダウンロード</h2>
      <div class="row" style="margin-bottom:10px">
        <button id="btnDlAll" class="btn" disabled>すべてをZIPでDL</button>
      </div>
      <div id="preview" class="preview">
        <div class="help">ここに各文字のSVGを表示します。</div>
      </div>
    </section>
  </div>

  <div id="loading" class="loadingOverlay" role="alert" aria-live="polite">
    <div class="loadingPanel">
      <div class="spinner" aria-hidden="true"></div>
      <div class="loadingText">
        <div id="loadingMsg">処理中です…</div>
        <div id="loadingPct"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
  (function(){
    const $ = id => document.getElementById(id);

    const elListBtn = $("btnListLocal");
    const elList = $("localList");
    const elFontName = $("fontName");
    const elSupport = $("supportNote");

      const elText = $("text");
      const elPrec = $("prec");
      const elPrecVal = $("precVal");
    const elMode = $("mode");
    const elStrokeW = $("strokeW");
    const elColor = $("color");
    const elSkipSpace = $("skipSpace");

    const elGen = $("btnGen");
    const elStatus = $("status");

    const elPreview = $("preview");
    const elDlAll = $("btnDlAll");

    const PREVIEW_SIZE = 300;
    const PREVIEW_HEIGHT = 220;
    const OUTPUT_SIZE = 480;

    let otFont = null;
    let isSwitchingFont = false;
    let lastGenerated = false;
    let currentFontName = '';

    const supportLocal = typeof window.queryLocalFonts === 'function';
    if (!supportLocal) {
      elListBtn.disabled = true;
      if (elGen) elGen.disabled = true;
      elSupport.textContent = 'この環境では Local Font Access を利用できません。Chromium系ブラウザをご利用ください。';
    }

      elPrec.addEventListener('input', ()=> elPrecVal.textContent = elPrec.value);
      elColor.addEventListener('input', async ()=>{
        if (lastGenerated && !isSwitchingFont) {
          await generateAll({ instant: true });
        }
      });
      elMode.addEventListener('change', async ()=>{
        if (lastGenerated && !isSwitchingFont) {
          await generateAll({ instant: true });
        }
      });
      elStrokeW.addEventListener('input', async ()=>{
        if (lastGenerated && !isSwitchingFont) {
          await generateAll({ instant: true });
        }
      });

    function setStatus(msg){ elStatus.textContent = msg || ''; }

    // ファイル名の危険文字を安全化
    function safeName(s){
      return String(s ?? 'LocalFont').replace(/[\\/:*?"<>|\r\n]/g,'_').trim() || 'LocalFont';
    }

    function isCollectionBuffer(buf){
      if(!buf || buf.byteLength < 4) return false;
      const u8 = new Uint8Array(buf, 0, 4);
      const head = String.fromCharCode(u8[0], u8[1], u8[2], u8[3]).toLowerCase();
      return head === 'ttcf';
    }

    function readBlobWithProgress(blob, onProgress){
      return new Promise((resolve, reject)=>{
        const fr = new FileReader();
        fr.onprogress = e=>{ if(e.lengthComputable && typeof onProgress === 'function'){ onProgress(e.loaded, e.total); } };
        fr.onload = ()=> resolve(fr.result);
        fr.onerror = err=> reject(err);
        fr.readAsArrayBuffer(blob);
      });
    }

    const showLoading = (msg)=>{
      const el = document.getElementById('loading');
      const msgEl = document.getElementById('loadingMsg');
      const pctEl = document.getElementById('loadingPct');
      if (el) {
        el.classList.add('show');
        if (msgEl) msgEl.textContent = msg || '処理中です…';
        if (pctEl) pctEl.textContent = '';
      }
    };
    const updateLoadingProgress = (current,total)=>{
      const pctEl = document.getElementById('loadingPct');
      if (pctEl && total > 0) {
        const pct = Math.floor((current/total)*100);
        pctEl.textContent = pct + '%';
      }
    };
    const hideLoading = ()=>{
      const el = document.getElementById('loading');
      const pctEl = document.getElementById('loadingPct');
      if (el) el.classList.remove('show');
      if (pctEl) pctEl.textContent = '';
    };

    elListBtn.addEventListener('click', async ()=>{
      if(!supportLocal) return;
      try{
        elListBtn.disabled = true;
        showLoading('ローカルフォントを取得しています…');

        const fonts = await window.queryLocalFonts();
        const seen = new Set();
        const unique = [];
        for(const f of fonts){
          const key = f.postscriptName || f.fullName || (f.family+':'+(f.style||''));
          if(!seen.has(key)){ seen.add(key); unique.push(f); }
        }
        unique.sort((a,b)=> (a.fullName||a.family).localeCompare(b.fullName||b.family));

        const supported = [];
        updateLoadingProgress(0, unique.length);
        for(let i=0;i<unique.length;i++){
          const fd = unique[i];
          try{
            const blob = await fd.blob();
            const headBuf = await blob.slice(0,4).arrayBuffer();
            if(isCollectionBuffer(headBuf)) continue;
            supported.push(fd);
          }catch(e){}
          updateLoadingProgress(i+1, unique.length);
        }

        elList.innerHTML = '<option value="">▼ フォントを選択</option>'
          + supported.map((f,i)=> `<option value="${i}">${escapeHtml(f.fullName || f.postscriptName || (f.family+' '+(f.style||'')))}</option>`).join('');
        elList.style.display = 'inline-block';
        setStatus(`ローカルフォント ${supported.length} 件`);

        elList.onchange = async ()=>{
          if (isSwitchingFont) return;
          isSwitchingFont = true;
          const idx = Number(elList.value);
          const fd = supported[idx];
          if(!fd){ isSwitchingFont = false; return; }

            // Keep "SVGを生成" button enabled when a font is already loaded to avoid flicker
            elList.disabled = true; if (!otFont && elGen) elGen.disabled = true;
          showLoading('フォントを読み込んでいます…');
          updateLoadingProgress(0,1);
          try{
            const blob = await fd.blob();
            const buf = await readBlobWithProgress(blob, (loaded,total)=> updateLoadingProgress(loaded,total));
            otFont = opentype.parse(buf);
            elFontName.textContent = fd.fullName || fd.postscriptName || fd.family || 'Local Font';
            currentFontName = elFontName.textContent;
            if (elGen) elGen.disabled = false;
            setStatus('フォントを読み込みました。');
            if (lastGenerated) { await generateAll({ instant: false }); }
          }catch(err){
            console.error(err);
            setStatus('フォントの解析に失敗しました。');
          }finally{
            hideLoading();
            elList.disabled = false;
            if (!otFont && elGen) elGen.disabled = true;
            isSwitchingFont = false;
          }
        };
      }catch(err){
        console.error(err);
        setStatus('ローカルフォントの取得に失敗しました。');
      }finally{
        hideLoading();
        elListBtn.disabled = false;
      }
    });

    // 文字→SVG
    function buildSVGForChar(font, ch, opts){
      const { sizePx, precision, mode, strokeWidth, color } = opts;
      const scale = sizePx / font.unitsPerEm;
      const glyph = font.charToGlyph ? font.charToGlyph(ch) : font.stringToGlyphs(ch)[0];

      // 固定サイズの viewBox を用意し、文字位置のみ調整する
      const m = sizePx * 0.08; // マージン
      const width  = Math.ceil(font.unitsPerEm * scale + 2*m);
      const height = Math.ceil((font.ascender - font.descender) * scale + 2*m);

      // 描画パスを取得（ベースラインをフォントアセンダ位置に合わせる）
      const gp = glyph.getPath(0, font.ascender * scale, sizePx);
      const d = gp.toPathData(precision);

      // バウンディングボックスから横方向のみ平行移動量を算出（縦方向はベースライン基準で揃える）
      let tx = m, ty = m;
      if (typeof gp.getBoundingBox === 'function'){
        const bb = gp.getBoundingBox();
        const glyphW = bb.x2 - bb.x1;
        tx = (width - glyphW) / 2 - bb.x1;
        // ty はベースラインを共通に保つため一定値とする
      }

      const style = (mode==='solid') ? `fill: ${color};` : `fill: none; stroke: ${color}; stroke-width: ${strokeWidth};`;
      const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${sizePx}" height="${sizePx}" viewBox="0 0 ${width} ${height}">\n  <g style="${style}">\n    <path d="${d}" transform="translate(${tx},${ty})"/>\n  </g>\n</svg>`;
      return svg;
    }

    // テキスト全体 → SVG
    function buildSVGForText(text, opts){
      if(!otFont) return '';
      const { sizePx, precision, mode, strokeWidth, color } = opts;
      const scale = sizePx / otFont.unitsPerEm;
      const m = sizePx * 0.08; // マージン

      const lineHeight = (otFont.ascender - otFont.descender) * scale;
      const lines = String(text).replace(/\r\n?/g,'\n').split('\n');
      const fullPath = new opentype.Path();
      let width = 0;
      for(let i=0;i<lines.length;i++){
        const line = lines[i];
        const p = otFont.getPath(line, 0, otFont.ascender * scale + i * lineHeight, sizePx);
        fullPath.commands.push(...p.commands);
        width = Math.max(width, otFont.getAdvanceWidth(line, sizePx));
      }
      const d = fullPath.toPathData(precision);

      width = Math.ceil(width + 2 * m);
      const height = Math.ceil(lineHeight * lines.length + 2 * m);

      let tx = m, ty = m;
      if (typeof fullPath.getBoundingBox === 'function'){
        const bb = fullPath.getBoundingBox();
        tx = m - bb.x1;
        ty = m - bb.y1;
      }

      const style = (mode==='solid') ? `fill: ${color};` : `fill: none; stroke: ${color}; stroke-width: ${strokeWidth};`;
      const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">\n  <g style="${style}">\n    <path d="${d}" transform="translate(${tx},${ty})"/>\n  </g>\n</svg>`;
      return svg;
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    function* iterCharsIgnoringNewlines(str){
      const noNL = String(str).replace(/\r\n?/g,'\n').replace(/\n/g,'');
      for(const ch of Array.from(noNL)) yield ch;
    }

    // タイル（個別ダウンロード名に 0 埋め連番を付与）
    function makeTile(char, svg, idx, pad){
      const tile = document.createElement('div');
      tile.className = 'tile';
      const box = document.createElement('div');
      box.className = 'box';
      box.innerHTML = svg;
      const svgEl = box.querySelector('svg');
      if (svgEl) {
        svgEl.setAttribute('width', PREVIEW_SIZE);
        svgEl.setAttribute('height', PREVIEW_HEIGHT);
      }
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `<span>#${idx+1}「${escapeHtml(char)}」</span>`;
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = 'このSVGをDL';
      btn.addEventListener('click', ()=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([svg], {type:'image/svg+xml'}));
        a.download = `N${pad(idx+1)}_${safeName(char)}.svg`;
        a.click();
        URL.revokeObjectURL(a.href);
      });
      const foot = document.createElement('div');
      foot.style.display='flex'; foot.style.gap='8px';
      foot.appendChild(meta); foot.appendChild(btn);
      tile.appendChild(box); tile.appendChild(foot);
      return tile;
    }

    // 生成（1文字ずつ）
    async function generateAll(opts = {}){
      const { instant = false } = opts;
      if(!otFont){ setStatus('先にフォントを選択してください。'); return; }
      const sizePx = OUTPUT_SIZE;
      const precision = Number(elPrec.value);
      const mode = elMode.value; const strokeWidth = Number(elStrokeW.value);
      const color = elColor.value;
      const skipSpace = elSkipSpace.checked;

      setStatus('SVG を生成しています…');
      if (!instant) {
        elPreview.classList.add('swap-off');
        await new Promise(r => requestAnimationFrame(r));
        elPreview.innerHTML = '';
      }
      const grid = document.createElement('div');
      grid.className = 'grid';

      const chars = [];
      for(const ch of iterCharsIgnoringNewlines(elText.value)){
        if(skipSpace && /^\s$/.test(ch)) continue;
        chars.push(ch);
      }
      if(chars.length===0){ setStatus('対象の文字がありませんでした。'); lastGenerated = false; return; }

      // 0埋め関数：総数の桁数に合わせる
      const total = chars.length;
      const width = String(total).length;
      const pad = n => String(n).padStart(width,'0');

      const svgs = [];
      for(let i=0;i<chars.length;i++){
        const ch = chars[i];
        try{
          const svg = buildSVGForChar(otFont, ch, { sizePx, precision, mode, strokeWidth, color });
          svgs.push({ ch, svg });
          grid.appendChild(makeTile(ch, svg, i, pad));
        }catch(err){ console.error(err); }
      }
      const fullTextSvg = buildSVGForText(elText.value, { sizePx, precision, mode, strokeWidth, color });

      elPreview.replaceChildren(grid);
      elDlAll.disabled = false;
      lastGenerated = true;
      setStatus(`生成が完了しました（${svgs.length} 文字）。`);
      if (!instant) {
        requestAnimationFrame(()=>{ elPreview.classList.remove('swap-off'); });
      } else {
        elPreview.classList.remove('swap-off');
      }

      // 一括ZIP
      elDlAll.onclick = async ()=>{
        if(!window.JSZip){ alert('JSZip を読み込めませんでした。'); return; }
        const zip = new JSZip();
        for(let i=0;i<svgs.length;i++){
          const {ch, svg} = svgs[i];
          zip.file(`N${pad(i+1)}_${safeName(ch)}.svg`, svg);
        }
        zip.file('full_text.svg', fullTextSvg);
        const blob = await zip.generateAsync({type:'blob'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);

        // ZIP名：日時とフォント名（安全化、空白はハイフンに変換）を付与
        const dt = new Date();
        const y = dt.getFullYear();
        const m = String(dt.getMonth()+1).padStart(2,'0');
        const d = String(dt.getDate()).padStart(2,'0');
        const hh = String(dt.getHours()).padStart(2,'0');
        const mm = String(dt.getMinutes()).padStart(2,'0');
        const ss = String(dt.getSeconds()).padStart(2,'0');
        const safeFontName = safeName(currentFontName).replace(/\s+/g,'-');
        const zipName = `svgs_${y}${m}${d}-${hh}${mm}${ss}_${safeFontName}.zip`;

        a.download = zipName;
        a.click();
        URL.revokeObjectURL(a.href);
      };
    }

    elGen.addEventListener('click', async ()=>{ await generateAll(); });

  })();
  </script>
</body>
</html>
