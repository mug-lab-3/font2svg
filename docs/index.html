<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>文字ごとのSVGアウトライン生成（Local Fonts・単一ファイル）</title>
  <style>
    :root{--bg:#0f0d11;--fg:#f8fafc;--muted:#94a3b8;--card:#1f1f28;--ring:#374151;--pri:#ac00ac;--accent:#00acac}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.6 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif}
    .wrap{max-width:980px;margin:40px auto;padding:0 16px;display:grid;gap:16px}
    h1{font-size:22px;margin:0 0 4px}
    h2{font-size:18px;margin:0 0 8px}
    .card{background:var(--card);border:1px solid var(--ring);border-radius:14px;padding:14px;box-shadow:0 1px 2px rgba(0,0,0,.03)}
    .row{display:flex;flex-wrap:wrap;gap:12px;align-items:center}
    .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;background:var(--pri);color:#fff;cursor:pointer}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    label.inline{display:inline-flex;align-items:center;gap:8px}
    select,textarea,input[type="number"],input[type="range"],input[type="checkbox"]{padding:8px 10px;border-radius:10px;border:1px solid var(--ring);background:#1f2937;color:var(--fg)}
    a{color:var(--accent)}
    textarea{min-width:420px;min-height:80px}
    input[type="range"]{vertical-align:middle}
    .help{color:var(--muted);font-size:12px}
    .status{font-size:13px;color:var(--muted);margin-left:8px}
    .preview{min-height:260px;border:1px dashed var(--ring);border-radius:12px;background:var(--card);padding:10px;overflow:auto;transition:opacity .14s ease;will-change:opacity;contain:paint}
    .preview.swap-off{opacity:0}
    .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px}
    .tile{background:var(--card);border:1px solid var(--ring);border-radius:12px;padding:8px;display:flex;flex-direction:column;gap:6px}
    .tile .box{background:var(--bg);border:1px solid var(--ring);border-radius:10px;display:flex;align-items:center;justify-content:center;min-height:160px;overflow:auto}
    .tile .meta{font-size:12px;color:var(--muted);display:flex;justify-content:space-between;gap:8px}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:var(--accent);color:#000;font-size:12px}

    /* Loading overlay（一覧取得時のみ使用／フェード） */
    .loadingOverlay{
      position:fixed; inset:0; background:rgba(0,0,0,.35);
      display:flex; align-items:center; justify-content:center; z-index:1000;
      opacity:0; pointer-events:none; transition:opacity .18s ease;
    }
    .loadingOverlay.show{ opacity:1; pointer-events:auto; }
    .loadingPanel{background:var(--card);border:1px solid var(--ring);border-radius:14px;padding:12px 16px;box-shadow:0 10px 24px rgba(0,0,0,.08);display:flex;align-items:center;gap:10px}
    .loadingText{display:flex;flex-direction:column;gap:2px}
    #loadingPct{font-size:12px;color:var(--muted);text-align:right}
    .spinner{width:22px;height:22px;border:3px solid var(--ring);border-top-color:var(--pri);border-radius:50%;animation:spin 1s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>文字ごとのSVGアウトライン生成 <span class="pill">Local Fonts 専用</span></h1>
      <p class="help">お使いの端末にインストールされているフォントを選び、入力テキスト（改行は無視）を<strong>1文字ごとに独立したSVG</strong>に変換します。処理はすべてお使いのブラウザ内で完結し、入力文字列やフォントデータが外部に送信されることはありません。</p>
    </header>

    <section class="card">
      <h2>1. フォントを選択</h2>
      <div class="row">
        <button id="btnListLocal" class="btn">ローカルフォントを表示</button>
        <select id="localList" style="min-width:360px;display:none"></select>
      </div>
      <div class="help">選択中のフォント: <b id="fontName">（未選択）</b></div>
      <p class="help">この機能は Google Chrome／Microsoft Edge／Brave などの「Chromium系」ブラウザでご利用いただけます。初回は「このサイトにパソコン内のフォントの一覧を表示してよいですか？」という確認が表示されます。<strong>［許可］</strong>を選ぶと、インストール済みフォントをメニューから選択できるようになります。</p>
      <div class="help" id="supportNote"></div>
    </section>

    <section class="card">
      <h2>2. テキストと出力設定</h2>
      <div class="row">
        <label class="inline" style="align-items:flex-start">テキスト（改行は無視）
          <textarea id="text">漢字ひらがなカタカナABC123!%$
改行は無視</textarea>
        </label>
      </div>
      <div class="row" style="margin-top:6px">
        <label class="inline">小数桁 <input id="prec" type="range" min="0" max="4" step="1" value="3"/> <span id="precVal">3</span></label>
        <label class="inline">描画モード
          <select id="mode">
            <option value="solid">塗り</option>
            <option value="stroke">輪郭線</option>
          </select>
        </label>
        <label class="inline">線幅 <input id="strokeW" type="number" value="1.5" min="0.5" step="0.5" style="width:80px"/> px</label>
        <label class="inline">空白を除外 <input id="skipSpace" type="checkbox" checked /></label>
      </div>
      <div style="margin-top:8px">
        <button id="btnGen" class="btn" disabled>1文字ずつSVGを生成</button>
        <span id="status" class="status"></span>
      </div>
    </section>

    <section class="card">
      <h2>3. プレビューと一括ダウンロード</h2>
      <div class="row" style="margin-bottom:10px">
        <button id="btnDlAll" class="btn" disabled>すべてをZIPでダウンロード</button>
      </div>
      <div id="preview" class="preview">
        <div class="help">ここに各文字のSVGを表示します。</div>
      </div>
    </section>
  </div>

  <div id="loading" class="loadingOverlay" role="alert" aria-live="polite">
    <div class="loadingPanel">
      <div class="spinner" aria-hidden="true"></div>
      <div class="loadingText">
        <div id="loadingMsg">処理中です…</div>
        <div id="loadingPct"></div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <script>
  (function(){
    const $ = id => document.getElementById(id);

    const elListBtn = $("btnListLocal");
    const elList = $("localList");
    const elFontName = $("fontName");
    const elSupport = $("supportNote");

      const elText = $("text");
      const elPrec = $("prec");
      const elPrecVal = $("precVal");
    const elMode = $("mode");
    const elStrokeW = $("strokeW");
    const elSkipSpace = $("skipSpace");

    const elGen = $("btnGen");
    const elStatus = $("status");

    const elPreview = $("preview");
    const elDlAll = $("btnDlAll");

    let otFont = null;
    let isSwitchingFont = false;
    let lastGenerated = false;
    let currentFontName = '';

    const supportLocal = typeof window.queryLocalFonts === 'function';
    if (!supportLocal) {
      elListBtn.disabled = true;
      if (elGen) elGen.disabled = true;
      elSupport.textContent = 'この環境では Local Font Access を利用できません。Chromium系ブラウザをご利用ください。';
    }

      elPrec.addEventListener('input', ()=> elPrecVal.textContent = elPrec.value);

    function setStatus(msg){ elStatus.textContent = msg || ''; }

    // ファイル名の危険文字を安全化
    function safeName(s){
      return String(s ?? 'LocalFont').replace(/[\\/:*?"<>|\r\n]/g,'_').trim() || 'LocalFont';
    }

    function isCollectionBuffer(buf){
      if(!buf || buf.byteLength < 4) return false;
      const u8 = new Uint8Array(buf, 0, 4);
      const head = String.fromCharCode(u8[0], u8[1], u8[2], u8[3]).toLowerCase();
      return head === 'ttcf';
    }

    function readBlobWithProgress(blob, onProgress){
      return new Promise((resolve, reject)=>{
        const fr = new FileReader();
        fr.onprogress = e=>{ if(e.lengthComputable && typeof onProgress === 'function'){ onProgress(e.loaded, e.total); } };
        fr.onload = ()=> resolve(fr.result);
        fr.onerror = err=> reject(err);
        fr.readAsArrayBuffer(blob);
      });
    }

    const showLoading = (msg)=>{
      const el = document.getElementById('loading');
      const msgEl = document.getElementById('loadingMsg');
      const pctEl = document.getElementById('loadingPct');
      if (el) {
        el.classList.add('show');
        if (msgEl) msgEl.textContent = msg || '処理中です…';
        if (pctEl) pctEl.textContent = '';
      }
    };
    const updateLoadingProgress = (current,total)=>{
      const pctEl = document.getElementById('loadingPct');
      if (pctEl && total > 0) {
        const pct = Math.floor((current/total)*100);
        pctEl.textContent = pct + '%';
      }
    };
    const hideLoading = ()=>{
      const el = document.getElementById('loading');
      const pctEl = document.getElementById('loadingPct');
      if (el) el.classList.remove('show');
      if (pctEl) pctEl.textContent = '';
    };

    elListBtn.addEventListener('click', async ()=>{
      if(!supportLocal) return;
      try{
        elListBtn.disabled = true;
        showLoading('ローカルフォントを取得しています…');

        const fonts = await window.queryLocalFonts();
        const seen = new Set();
        const unique = [];
        for(const f of fonts){
          const key = f.postscriptName || f.fullName || (f.family+':'+(f.style||''));
          if(!seen.has(key)){ seen.add(key); unique.push(f); }
        }
        unique.sort((a,b)=> (a.fullName||a.family).localeCompare(b.fullName||b.family));

        const supported = [];
        updateLoadingProgress(0, unique.length);
        for(let i=0;i<unique.length;i++){
          const fd = unique[i];
          try{
            const blob = await fd.blob();
            const headBuf = await blob.slice(0,4).arrayBuffer();
            if(isCollectionBuffer(headBuf)) continue;
            supported.push(fd);
          }catch(e){}
          updateLoadingProgress(i+1, unique.length);
        }

        elList.innerHTML = '<option value="">▼ フォントを選択</option>'
          + supported.map((f,i)=> `<option value="${i}">${escapeHtml(f.fullName || f.postscriptName || (f.family+' '+(f.style||'')))}</option>`).join('');
        elList.style.display = 'inline-block';
        setStatus(`ローカルフォント ${supported.length} 件`);

        elList.onchange = async ()=>{
          if (isSwitchingFont) return;
          isSwitchingFont = true;
          const idx = Number(elList.value);
          const fd = supported[idx];
          if(!fd){ isSwitchingFont = false; return; }

          elList.disabled = true; if (elGen) elGen.disabled = true;
          showLoading('フォントを読み込んでいます…');
          updateLoadingProgress(0,1);
          try{
            const blob = await fd.blob();
            const buf = await readBlobWithProgress(blob, (loaded,total)=> updateLoadingProgress(loaded,total));
            otFont = opentype.parse(buf);
            elFontName.textContent = fd.fullName || fd.postscriptName || fd.family || 'Local Font';
            currentFontName = elFontName.textContent;
            if (elGen) elGen.disabled = false;
            setStatus('フォントを読み込みました。');
            if (lastGenerated) { await generateAll(); }
          }catch(err){
            console.error(err);
            setStatus('フォントの解析に失敗しました。');
          }finally{
            hideLoading();
            elList.disabled = false;
            if (!otFont && elGen) elGen.disabled = true;
            isSwitchingFont = false;
          }
        };
      }catch(err){
        console.error(err);
        setStatus('ローカルフォントの取得に失敗しました。');
      }finally{
        hideLoading();
        elListBtn.disabled = false;
      }
    });

    // 文字→SVG
    function buildSVGForChar(font, ch, opts){
      const { sizePx, precision, mode, strokeWidth } = opts;
      const scale = sizePx / font.unitsPerEm;
      const glyph = font.charToGlyph ? font.charToGlyph(ch) : font.stringToGlyphs(ch)[0];

      // 固定サイズの viewBox を用意し、文字位置のみ調整する
      const m = sizePx * 0.08; // マージン
      const width  = Math.ceil(font.unitsPerEm * scale + 2*m);
      const height = Math.ceil((font.ascender - font.descender) * scale + 2*m);

      // 描画パスを取得（ベースラインをフォントアセンダ位置に合わせる）
      const gp = glyph.getPath(0, font.ascender * scale, sizePx);
      const d = gp.toPathData(precision);

      // バウンディングボックスから横方向のみ平行移動量を算出（縦方向はベースライン基準で揃える）
      let tx = m, ty = m;
      if (typeof gp.getBoundingBox === 'function'){
        const bb = gp.getBoundingBox();
        const glyphW = bb.x2 - bb.x1;
        tx = (width - glyphW) / 2 - bb.x1;
        // ty はベースラインを共通に保つため一定値とする
      }

      const style = (mode==='solid') ? `fill: black;` : `fill: none; stroke: black; stroke-width: ${strokeWidth};`;
      const svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${sizePx}" height="${sizePx}" viewBox="0 0 ${width} ${height}">\n  <g style="${style}">\n    <path d="${d}" transform="translate(${tx},${ty})"/>\n  </g>\n</svg>`;
      return svg;
    }

    function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }

    function* iterCharsIgnoringNewlines(str){
      const noNL = String(str).replace(/\r\n?/g,'\n').replace(/\n/g,'');
      for(const ch of Array.from(noNL)) yield ch;
    }

    // タイル（個別ダウンロード名に 0 埋め連番を付与）
    function makeTile(char, svg, idx, pad){
      const tile = document.createElement('div');
      tile.className = 'tile';
      const box = document.createElement('div');
      box.className = 'box';
      const previewSvg = svg
        .replace(/fill:\s*black;/g, 'fill: #fff;')
        .replace(/stroke:\s*black;/g, 'stroke: #fff;');
      box.innerHTML = previewSvg;
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.innerHTML = `<span>#${idx+1}「${escapeHtml(char)}」</span>`;
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.textContent = 'このSVGをダウンロード';
      btn.addEventListener('click', ()=>{
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([svg], {type:'image/svg+xml'}));
        a.download = `${pad(idx+1)}_${safeName(char)}.svg`;
        a.click();
        URL.revokeObjectURL(a.href);
      });
      const foot = document.createElement('div');
      foot.style.display='flex'; foot.style.gap='8px';
      foot.appendChild(meta); foot.appendChild(btn);
      tile.appendChild(box); tile.appendChild(foot);
      return tile;
    }

    // 生成（1文字ずつ）
    async function generateAll(){
      if(!otFont){ setStatus('先にフォントを選択してください。'); return; }
      const sizePx = 300;
      const precision = Number(elPrec.value);
      const mode = elMode.value; const strokeWidth = Number(elStrokeW.value);
      const skipSpace = elSkipSpace.checked;

      setStatus('SVG を生成しています…');
      elPreview.classList.add('swap-off');
      await new Promise(r => requestAnimationFrame(r));

      elPreview.innerHTML = '';
      const grid = document.createElement('div');
      grid.className = 'grid';

      const chars = [];
      for(const ch of iterCharsIgnoringNewlines(elText.value)){
        if(skipSpace && /^\s$/.test(ch)) continue;
        chars.push(ch);
      }
      if(chars.length===0){ setStatus('対象の文字がありませんでした。'); lastGenerated = false; return; }

      // 0埋め関数：総数の桁数に合わせる
      const total = chars.length;
      const width = String(total).length;
      const pad = n => String(n).padStart(width,'0');

      const svgs = [];
      for(let i=0;i<chars.length;i++){
        const ch = chars[i];
        try{
          const svg = buildSVGForChar(otFont, ch, { sizePx, precision, mode, strokeWidth });
          svgs.push({ ch, svg });
          grid.appendChild(makeTile(ch, svg, i, pad));
        }catch(err){ console.error(err); }
      }
      elPreview.appendChild(grid);
      elDlAll.disabled = false;
      lastGenerated = true;
      setStatus(`生成が完了しました（${svgs.length} 文字）。`);
      requestAnimationFrame(()=>{ elPreview.classList.remove('swap-off'); });

      // 一括ZIP
      elDlAll.onclick = async ()=>{
        if(!window.JSZip){ alert('JSZip を読み込めませんでした。'); return; }
        const zip = new JSZip();
        for(let i=0;i<svgs.length;i++){
          const {ch, svg} = svgs[i];
          zip.file(`${pad(i+1)}_${safeName(ch)}.svg`, svg);
        }
        const blob = await zip.generateAsync({type:'blob'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);

        // ZIP名：日時とフォント名（安全化）を付与
        const dt = new Date();
        const y = dt.getFullYear();
        const m = String(dt.getMonth()+1).padStart(2,'0');
        const d = String(dt.getDate()).padStart(2,'0');
        const hh = String(dt.getHours()).padStart(2,'0');
        const mm = String(dt.getMinutes()).padStart(2,'0');
        const ss = String(dt.getSeconds()).padStart(2,'0');
        const zipName = `svgs_${y}${m}${d}-${hh}${mm}${ss}_${safeName(currentFontName)}.zip`;

        a.download = zipName;
        a.click();
        URL.revokeObjectURL(a.href);
      };
    }

    elGen.addEventListener('click', async ()=>{ await generateAll(); });

  })();
  </script>
</body>
</html>
